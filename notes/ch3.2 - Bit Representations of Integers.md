<p align=right>Week 3</p>

# Bit Representations of Integers
정수의 비트 표현. 따로 있는 섹션은 아니지만 섹션으로 빼는 게 나아 보여 따로 작성

## Unsigned Integers
그냥 2진법 표현을 비트에다 넣음

| 비트 수 | 범위 |
| ------ | --- |
| 8 | 0 .. 2<sup>8</sup> - 1 = 255 |
| 16 | 0 .. 2<sup>16</sup> - 1 = 65 535 |
| 32 | 0 .. 2<sup>32</sup> - 1 = 2 147 483 647 |
| 64 | 0 .. 2<sup>64</sup> - 1 ~= 1.8 × 10<sup>19 |

## Signed Numbers
세 가지 표현방식이 있다
* Signed Magnitude
* 1's complement
* **2's complement** <- 주로 쓰임

## Signed Magnitude
첫 비트(sign bit)는 부호, 두 번째부터는 절댓값(magnitude). n비트 signed magnitude 값의 범위는 -2<sup>n - 1</sup> + 1 .. 2<sup>n - 1</sup> - 1

| 값 | 4비트 표현 | 값 | 4비트 표현 |
| -- | -------- | -- | -------- |
| +7 | `0 111` | -7 | `1 111` |
| +4 | `0 100` | -4 | `1 100` |
| +2 | `0 010` | -2 | `1 010` |
| +1 | `0 001` | -1 | `1 001` |
| +0 | `0 000` | -0 | `1 000` |

부호 변환이 쉽고, 얼핏 보면 직관적이라고 생각할 수도 있겠으나
* 0이 두 개 존재한다
* 하드웨어로 연산 구현하기가 힘들다

### 덧셈 알고리즘
뺄셈은 덧셈으로 간주 (3 - 4 = 3 + (-4))

* 두 수의 부호가 같으면 그냥 더한다
* 두 수의 부호가 다르면:
  * 절댓값이 큰 수의 절댓값에서, 절댓값이 작은 수의 절댓값을 뺀다
  * 절댓값이 큰 수와 절댓값이 작은 수의 부호에 따라 결과의 부호가 결정

복잡해서 예전 시스템에밖에 안 쓰인다.

## 1's complement
첫 비트(sign bit)는 부호, 두 번째부터는 절댓값(magnitude)인데 음수일 경우 bitwise NOT이 된다.
n비트 1's complement 값의 범위는 -2<sup>n - 1</sup> + 1 .. 2<sup>n - 1</sup> - 1

| 값 | 4비트 표현 | 값 | 4비트 표현 |
| -- | -------- | -- | -------- |
| +7 | `0 111` | -7 | `1 000` |
| +4 | `0 100` | -4 | `1 011` |
| +2 | `0 010` | -2 | `1 101` |
| +1 | `0 001` | -1 | `1 110` |
| +0 | `0 000` | -0 | `1 111` |

덜 직관적이긴 하지만 연산 구현은 Signed Magnitude보다 쉽다. 그래도 0이 두 개라는 단점이 있다.

### 덧셈 알고리즘
일단 그냥 가산기로 비트끼리 더하고, 맨 왼쪽에 carry bit이 있을 경우 1을 더해 준다. 

* `1 101` (-2) + `1 100` (-3) = `11 001` (-6?)
  * carry bit이 1이므로 다시 더해 주면 `1 010` (-5)
  
## 2's complement
첫 비트(sign bit)는 부호, 두 번째부터는 절댓값(magnitude)인데 음수일 경우 bitwise NOT 하고 더하기 1.
n비트 2's complement 값의 범위는 -2<sup>n - 1</sup> .. 2<sup>n - 1</sup> - 1


| 값 | 4비트 표현 | 값 | 4비트 표현 |
| -- | -------- | -- | -------- |
| +7 | `0 111` | -8 | `1 000` |
| +4 | `0 100` | -5 | `1 011` |
| +2 | `0 010` | -3 | `1 101` |
| +1 | `0 001` | -2 | `1 110` |
| 0 | `0 000` | -1 | `1 111` |

0이 한 개다!

### 덧셈 알고리즘
그냥 가산기로 비트끼리 더하면 된다. 너무 쉽다.

0이 한 개여서 -1 다음이 0이고, 그 다음이 1이기 때문이다. 1's의 경우 -1 다음이 -0, 그 다음이 +0, 그 다음이 +1이라서 carry bit을 더할 필요가
있었지만 이 경우 그렇지 않다.

* `0 101` (5) + `1 101` (-3) = `10 010` (+2) OK

요즘은 대부분이 이 시스템을 사용한다.
