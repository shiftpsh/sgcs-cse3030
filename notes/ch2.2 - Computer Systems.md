<p align=right>Week 2</p>

# Computer Systems

## Pipeline
분업이다.

[![초코파이 공정](https://img.youtube.com/vi/TH-kZqIwBno/0.jpg)](https://www.youtube.com/watch?v=TH-kZqIwBno)

예를 들어 공장에서 맛있는 초코파이😋를 만드려면

- 빵을 굽고
- 마시멜로를 얹고
- 초콜릿으로 코팅하고
- 비닐 포장
- 박스 포장

해야 되는데, 기계 한 대가 이걸 혼자 다 하는 것보다 빵 굽는 기계, 마시멜로 얹는 기계, 초코 코팅 하는 기계, 비닐 포장 하는 기계,
박스 포장 하는 기계가 **따로따로 있으면** 더 좋다

각 작업이 10초씩 걸린다고 치면 초코파이 하나가 나오는 데는 똑같이 50초가 걸리겠지만
- 전자는 한 대가 초코파이 하나를 전부 프로세싱 해야 다음 재료가 들어갈 수 있어서, 결국 **50초당 1개**의 초코파이가 나오는데
- 후자는 각 기계에서 각 작업이 끝나면 전 단계 기계에 있던 초코파이를 계속 가져오면 되니까 첫 초코파이가
나오는 데는 조금 오래 걸릴지 몰라도 일단 나오기 시작하기만 하면 **10초당 1개**의 초코파이가 나오게 된다

(1학년 때 인턴 할 때는 Pipeline이 정확히 뭔진 몰랐는데, [알고 보니 회사에 있을 때 pipeline에 대해서 발표를 하고 나왔었다.](https://blog.shift.moe/2018/09/05/camera2-overview/)
Camera1은 pipeline을 쓰지 않는데 Camera2는 pipeline을 써서 속도 개선을 이뤘다는 내용.)

아무튼
- Latency: task 하나를 완료하는 데 걸리는 시간
- Throughput: 단위시간당 완료하는 task 개수
로 두면 pipeline이 있든 없든 latency는 같은데 throughput은 pipeline을 도입하면 훨씬 개선할 수 있다

## Pipelines in CPU

가령 CPU 작업 하나는 6개의 작업으로 이루어져 있다고 치자. 이 때

* 파이프라인이 없다면: 

| Cycle | S1 | S2 | S3 | S4 | S5 | S6 |
| ----- | -- | -- | -- | -- | -- | -- |
|     1 | 1️⃣ |    |    |    |    |    |
|     2 |    | 1️⃣ |    |    |    |    |
|     3 |    |    | 1️⃣ |    |    |    |
|     4 |    |    |    | 1️⃣ |    |    |
|     5 |    |    |    |    | 1️⃣ |    |
|     6 |    |    |    |    |    | 1️⃣ |
|     7 | 2️⃣ |    |    |    |    |    |
|     8 |    | 2️⃣ |    |    |    |    |
|     9 |    |    | 2️⃣ |    |    |    |
|    10 |    |    |    | 2️⃣ |    |    |
|    11 |    |    |    |    | 2️⃣ |    |
|    12 |    |    |    |    |    | 2️⃣ |

* 파이프라인이 있다면: 

| Cycle | S1 | S2 | S3 | S4 | S5 | S6 |
| ----- | -- | -- | -- | -- | -- | -- |
|     1 | 1️⃣ |    |    |    |    |    |
|     2 | 2️⃣ | 1️⃣ |    |    |    |    |
|     3 | 3️⃣ | 2️⃣ | 1️⃣ |    |    |    |
|     4 | 4️⃣ | 3️⃣ | 2️⃣ | 1️⃣ |    |    |
|     5 |    | 4️⃣ | 3️⃣ | 2️⃣ | 1️⃣ |    |
|     6 |    |    | 4️⃣ | 3️⃣ | 2️⃣ | 1️⃣ |
|     7 |    |    |    | 4️⃣ | 3️⃣ | 2️⃣ |
|     8 |    |    |    |    | 4️⃣ | 3️⃣ |
|     9 |    |    |    |    |    | 4️⃣ |

* 이 떄 **최대한 균등하게** 작업을 분배해야 된다. 만약 작업 S4가 사이클 2개를 필요로 한다면 이렇게 **버리는 사이클**😠이 생기고, 결국 파이프라인을 쓰나 마나가 된다

| Cycle | S1 | S2 | S3 | S4 | S5 | S6 |
| ----- | -- | -- | -- | -- | -- | -- |
|     1 | 1️⃣ |    |    |    |    |    |
|     2 | 2️⃣ | 1️⃣ |    |    |    |    |
|     3 | 3️⃣ | 2️⃣ | 1️⃣ |    |    |    |
|     4 |    | 3️⃣ | 2️⃣ | 1️⃣ |    |    |
|     5 |    |    | 3️⃣ | *1️⃣* |    |    |
|     6 |    |    |    | 2️⃣ | 1️⃣ |    |
|     7 |    |    |    | *2️⃣* | 😠 | 1️⃣ |
|     8 |    |    |    | 3️⃣ | 2️⃣ | 😠 |
|     9 |    |    |    | *3️⃣* | 😠 | 2️⃣ |

* Superscalar 프로세서: S4를 병렬 처리할 수도 있다. 이렇게 하면 버려지는 사이클이 없게 된다. 아예 이런 걸 연구하는 분야도 있다고 한다

| Cycle | S1 | S2 | S3 | S4<sub>u</sub> | S4<sub>v</sub> | S5 | S6 |
| ----- | -- | -- | -- | -- | -- | -- | -- |
|     1 | 1️⃣ |    |    |    |    |    |    |
|     2 | 2️⃣ | 1️⃣ |    |    |    |    |    |
|     3 | 3️⃣ | 2️⃣ | 1️⃣ |    |    |    |    |
|     4 | 4️⃣ | 3️⃣ | 2️⃣ | 1️⃣ |    |    |    |
|     5 |    | 4️⃣ | 3️⃣ | *1️⃣* | 2️⃣ |    |    |
|     6 |    |    | 4️⃣ | 3️⃣ | *2️⃣* | 1️⃣ |    |
|     7 |    |    |    | *3️⃣* | 4️⃣ | 2️⃣ | 1️⃣ |
|     8 |    |    |    |    | *4️⃣* | 3️⃣ | 2️⃣ |
|     9 |    |    |    |    |    | 4️⃣ | 3️⃣ |

## More on Memory

* RAM: Random Access Memory. 어디에 저장돼 있든지 아무때나 읽을 수 있어서 Random Access다.
Random Access가 힘든 케이스는 마그네틱 테이프 같은 게 있겠다 (특정 위치로 가려면 테이프를 돌려야 하니)

| 종류 | 기능 | 속도 | 비트당 가격 | 용도 |
| --- | --- | --- | ------- | --- |
| DRAM (Dynamic RAM) | 액세스하지 않으면 데이터가 점차 지워짐, Refresh 필요 | 느리다 | 싸다 | 대용량 메모리 |
| SRAM (Static RAM) | 전원을 끄지 않는 이상 데이터가 안 날아긴다 | 빠르다 | 비싸다 | Cache 메모리, ASIC에 들어가는 메모리 |
| NVRAM (Non Volatile RAM / Flash Memory) | 전원을 꺼도 데이터가 유지된다 | ? | 비싸다 | SSD, USB 메모리 등 |

* ROM: Read-Only Memory
  * **[하드 디스크와 ROM은 상관이 없다.](https://technology.blurtit.com/182375/is-hard-disk-a-rom-or-ram)** 그냥 메모리에 쓸 수 없으면 ROM이다.
  * PROM: Programmable ROM
  * EPROM: Erasable ROM
  * EEPROM: Elecrically EPROM
  * 그냥 이런 것들이 있다는 거만 알아두자


